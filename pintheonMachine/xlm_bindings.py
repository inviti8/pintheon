# This file was generated by stellar_contract_bindings v0.5.0b0 and stellar_sdk v13.0.0.

from __future__ import annotations

from enum import IntEnum, Enum
from typing import Dict, List, Tuple, Optional, Union

from stellar_sdk import scval, xdr, Address, MuxedAccount, Keypair
from stellar_sdk.contract import AssembledTransaction, ContractClient
from stellar_sdk.contract import AssembledTransactionAsync, ContractClientAsync

NULL_ACCOUNT = "GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWHF"


class Client(ContractClient):
    def allowance(
        self,
        from_: Union[Address, str],
        spender: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        """Returns the allowance for `spender` to transfer from `from`.

        The amount returned is the amount that spender is allowed to transfer
        out of from's balance. When the spender transfers amounts, the allowance
        will be reduced by the amount transferred.

        # Arguments

        * `from` - The address holding the balance of tokens to be drawn from.
        * `spender` - The address spending the tokens held by `from`."""
        return self.invoke(
            "allowance",
            [scval.to_address(from_), scval.to_address(spender)],
            parse_result_xdr_fn=lambda v: scval.from_int128(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def authorized(
        self,
        id: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bool]:
        """Returns true if `id` is authorized to use its balance.

        # Arguments

        * `id` - The address for which token authorization is being checked."""
        return self.invoke(
            "authorized",
            [scval.to_address(id)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def approve(
        self,
        from_: Union[Address, str],
        spender: Union[Address, str],
        amount: int,
        expiration_ledger: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[None]:
        """Set the allowance by `amount` for `spender` to transfer/burn from
        `from`.

        The amount set is the amount that spender is approved to transfer out of
        from's balance. The spender will be allowed to transfer amounts, and
        when an amount is transferred the allowance will be reduced by the
        amount transferred.

        # Arguments

        * `from` - The address holding the balance of tokens to be drawn from.
        * `spender` - The address being authorized to spend the tokens held by
        `from`.
        * `amount` - The tokens to be made available to `spender`.
        * `expiration_ledger` - The ledger number where this allowance expires. Cannot
        be less than the current ledger number unless the amount is being set to 0.
        An expired entry (where expiration_ledger < the current ledger number)
        should be treated as a 0 amount allowance.

        # Events

        Emits an event with topics `["approve", from: Address,
        spender: Address], data = [amount: i128, expiration_ledger: u32]`"""
        return self.invoke(
            "approve",
            [
                scval.to_address(from_),
                scval.to_address(spender),
                scval.to_int128(amount),
                scval.to_uint32(expiration_ledger),
            ],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def balance(
        self,
        id: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        """Returns the balance of `id`.

        # Arguments

        * `id` - The address for which a balance is being queried. If the
        address has no existing balance, returns 0."""
        return self.invoke(
            "balance",
            [scval.to_address(id)],
            parse_result_xdr_fn=lambda v: scval.from_int128(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def burn(
        self,
        from_: Union[Address, str],
        amount: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[None]:
        """Burn `amount` from `from`.

        Reduces from's balance by the amount, without transferring the balance
        to another holder's balance.

        # Arguments

        * `from` - The address holding the balance of tokens which will be
        burned from.
        * `amount` - The amount of tokens to be burned.

        # Events

        Emits an event with topics `["burn", from: Address], data = amount:
        i128`"""
        return self.invoke(
            "burn",
            [scval.to_address(from_), scval.to_int128(amount)],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def burn_from(
        self,
        spender: Union[Address, str],
        from_: Union[Address, str],
        amount: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[None]:
        """Burn `amount` from `from`, consuming the allowance of `spender`.

        Reduces from's balance by the amount, without transferring the balance
        to another holder's balance.

        The spender will be allowed to burn the amount from from's balance, if
        the amount is less than or equal to the allowance that the spender has
        on the from's balance. The spender's allowance on from's balance will be
        reduced by the amount.

        # Arguments

        * `spender` - The address authorizing the burn, and having its allowance
        consumed during the burn.
        * `from` - The address holding the balance of tokens which will be
        burned from.
        * `amount` - The amount of tokens to be burned.

        # Events

        Emits an event with topics `["burn", from: Address], data = amount:
        i128`"""
        return self.invoke(
            "burn_from",
            [
                scval.to_address(spender),
                scval.to_address(from_),
                scval.to_int128(amount),
            ],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def clawback(
        self,
        from_: Union[Address, str],
        amount: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[None]:
        """Clawback `amount` from `from` account. `amount` is burned in the
        clawback process.

        # Arguments

        * `from` - The address holding the balance from which the clawback will
        take tokens.
        * `amount` - The amount of tokens to be clawed back.

        # Events

        Emits an event with topics `["clawback", admin: Address, to: Address],
        data = amount: i128`"""
        return self.invoke(
            "clawback",
            [scval.to_address(from_), scval.to_int128(amount)],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def decimals(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        """Returns the number of decimals used to represent amounts of this token.

        # Panics

        If the contract has not yet been initialized."""
        return self.invoke(
            "decimals",
            [],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def mint(
        self,
        to: Union[Address, str],
        amount: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[None]:
        """Mints `amount` to `to`.

        # Arguments

        * `to` - The address which will receive the minted tokens.
        * `amount` - The amount of tokens to be minted.

        # Events

        Emits an event with topics `["mint", admin: Address, to: Address], data
        = amount: i128`"""
        return self.invoke(
            "mint",
            [scval.to_address(to), scval.to_int128(amount)],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def name(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bytes]:
        """Returns the name for this token.

        # Panics

        If the contract has not yet been initialized."""
        return self.invoke(
            "name",
            [],
            parse_result_xdr_fn=lambda v: scval.from_string(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def set_admin(
        self,
        new_admin: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[None]:
        """Sets the administrator to the specified address `new_admin`.

        # Arguments

        * `new_admin` - The address which will henceforth be the administrator
        of this token contract.

        # Events

        Emits an event with topics `["set_admin", admin: Address], data =
        [new_admin: Address]`"""
        return self.invoke(
            "set_admin",
            [scval.to_address(new_admin)],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def admin(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[Address]:
        """Returns the admin of the contract.

        # Panics

        If the admin is not set."""
        return self.invoke(
            "admin",
            [],
            parse_result_xdr_fn=lambda v: scval.from_address(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def set_authorized(
        self,
        id: Union[Address, str],
        authorize: bool,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[None]:
        """Sets whether the account is authorized to use its balance. If
        `authorized` is true, `id` should be able to use its balance.

        # Arguments

        * `id` - The address being (de-)authorized.
        * `authorize` - Whether or not `id` can use its balance.

        # Events

        Emits an event with topics `["set_authorized", id: Address], data =
        [authorize: bool]`"""
        return self.invoke(
            "set_authorized",
            [scval.to_address(id), scval.to_bool(authorize)],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def symbol(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bytes]:
        """Returns the symbol for this token.

        # Panics

        If the contract has not yet been initialized."""
        return self.invoke(
            "symbol",
            [],
            parse_result_xdr_fn=lambda v: scval.from_string(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def transfer(
        self,
        from_: Union[Address, str],
        to: Union[Address, str],
        amount: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[None]:
        """Transfer `amount` from `from` to `to`.

        # Arguments

        * `from` - The address holding the balance of tokens which will be
        withdrawn from.
        * `to` - The address which will receive the transferred tokens.
        * `amount` - The amount of tokens to be transferred.

        # Events

        Emits an event with topics `["transfer", from: Address, to: Address],
        data = amount: i128`"""
        return self.invoke(
            "transfer",
            [scval.to_address(from_), scval.to_address(to), scval.to_int128(amount)],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def transfer_from(
        self,
        spender: Union[Address, str],
        from_: Union[Address, str],
        to: Union[Address, str],
        amount: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[None]:
        """Transfer `amount` from `from` to `to`, consuming the allowance that
        `spender` has on `from`'s balance. Authorized by spender
        (`spender.require_auth()`).

        The spender will be allowed to transfer the amount from from's balance
        if the amount is less than or equal to the allowance that the spender
        has on the from's balance. The spender's allowance on from's balance
        will be reduced by the amount.

        # Arguments

        * `spender` - The address authorizing the transfer, and having its
        allowance consumed during the transfer.
        * `from` - The address holding the balance of tokens which will be
        withdrawn from.
        * `to` - The address which will receive the transferred tokens.
        * `amount` - The amount of tokens to be transferred.

        # Events

        Emits an event with topics `["transfer", from: Address, to: Address],
        data = amount: i128`"""
        return self.invoke(
            "transfer_from",
            [
                scval.to_address(spender),
                scval.to_address(from_),
                scval.to_address(to),
                scval.to_int128(amount),
            ],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )


class ClientAsync(ContractClientAsync):
    async def allowance(
        self,
        from_: Union[Address, str],
        spender: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        """Returns the allowance for `spender` to transfer from `from`.

        The amount returned is the amount that spender is allowed to transfer
        out of from's balance. When the spender transfers amounts, the allowance
        will be reduced by the amount transferred.

        # Arguments

        * `from` - The address holding the balance of tokens to be drawn from.
        * `spender` - The address spending the tokens held by `from`."""
        return await self.invoke(
            "allowance",
            [scval.to_address(from_), scval.to_address(spender)],
            parse_result_xdr_fn=lambda v: scval.from_int128(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def authorized(
        self,
        id: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bool]:
        """Returns true if `id` is authorized to use its balance.

        # Arguments

        * `id` - The address for which token authorization is being checked."""
        return await self.invoke(
            "authorized",
            [scval.to_address(id)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def approve(
        self,
        from_: Union[Address, str],
        spender: Union[Address, str],
        amount: int,
        expiration_ledger: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[None]:
        """Set the allowance by `amount` for `spender` to transfer/burn from
        `from`.

        The amount set is the amount that spender is approved to transfer out of
        from's balance. The spender will be allowed to transfer amounts, and
        when an amount is transferred the allowance will be reduced by the
        amount transferred.

        # Arguments

        * `from` - The address holding the balance of tokens to be drawn from.
        * `spender` - The address being authorized to spend the tokens held by
        `from`.
        * `amount` - The tokens to be made available to `spender`.
        * `expiration_ledger` - The ledger number where this allowance expires. Cannot
        be less than the current ledger number unless the amount is being set to 0.
        An expired entry (where expiration_ledger < the current ledger number)
        should be treated as a 0 amount allowance.

        # Events

        Emits an event with topics `["approve", from: Address,
        spender: Address], data = [amount: i128, expiration_ledger: u32]`"""
        return await self.invoke(
            "approve",
            [
                scval.to_address(from_),
                scval.to_address(spender),
                scval.to_int128(amount),
                scval.to_uint32(expiration_ledger),
            ],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def balance(
        self,
        id: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        """Returns the balance of `id`.

        # Arguments

        * `id` - The address for which a balance is being queried. If the
        address has no existing balance, returns 0."""
        return await self.invoke(
            "balance",
            [scval.to_address(id)],
            parse_result_xdr_fn=lambda v: scval.from_int128(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def burn(
        self,
        from_: Union[Address, str],
        amount: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[None]:
        """Burn `amount` from `from`.

        Reduces from's balance by the amount, without transferring the balance
        to another holder's balance.

        # Arguments

        * `from` - The address holding the balance of tokens which will be
        burned from.
        * `amount` - The amount of tokens to be burned.

        # Events

        Emits an event with topics `["burn", from: Address], data = amount:
        i128`"""
        return await self.invoke(
            "burn",
            [scval.to_address(from_), scval.to_int128(amount)],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def burn_from(
        self,
        spender: Union[Address, str],
        from_: Union[Address, str],
        amount: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[None]:
        """Burn `amount` from `from`, consuming the allowance of `spender`.

        Reduces from's balance by the amount, without transferring the balance
        to another holder's balance.

        The spender will be allowed to burn the amount from from's balance, if
        the amount is less than or equal to the allowance that the spender has
        on the from's balance. The spender's allowance on from's balance will be
        reduced by the amount.

        # Arguments

        * `spender` - The address authorizing the burn, and having its allowance
        consumed during the burn.
        * `from` - The address holding the balance of tokens which will be
        burned from.
        * `amount` - The amount of tokens to be burned.

        # Events

        Emits an event with topics `["burn", from: Address], data = amount:
        i128`"""
        return await self.invoke(
            "burn_from",
            [
                scval.to_address(spender),
                scval.to_address(from_),
                scval.to_int128(amount),
            ],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def clawback(
        self,
        from_: Union[Address, str],
        amount: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[None]:
        """Clawback `amount` from `from` account. `amount` is burned in the
        clawback process.

        # Arguments

        * `from` - The address holding the balance from which the clawback will
        take tokens.
        * `amount` - The amount of tokens to be clawed back.

        # Events

        Emits an event with topics `["clawback", admin: Address, to: Address],
        data = amount: i128`"""
        return await self.invoke(
            "clawback",
            [scval.to_address(from_), scval.to_int128(amount)],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def decimals(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        """Returns the number of decimals used to represent amounts of this token.

        # Panics

        If the contract has not yet been initialized."""
        return await self.invoke(
            "decimals",
            [],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def mint(
        self,
        to: Union[Address, str],
        amount: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[None]:
        """Mints `amount` to `to`.

        # Arguments

        * `to` - The address which will receive the minted tokens.
        * `amount` - The amount of tokens to be minted.

        # Events

        Emits an event with topics `["mint", admin: Address, to: Address], data
        = amount: i128`"""
        return await self.invoke(
            "mint",
            [scval.to_address(to), scval.to_int128(amount)],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def name(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bytes]:
        """Returns the name for this token.

        # Panics

        If the contract has not yet been initialized."""
        return await self.invoke(
            "name",
            [],
            parse_result_xdr_fn=lambda v: scval.from_string(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def set_admin(
        self,
        new_admin: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[None]:
        """Sets the administrator to the specified address `new_admin`.

        # Arguments

        * `new_admin` - The address which will henceforth be the administrator
        of this token contract.

        # Events

        Emits an event with topics `["set_admin", admin: Address], data =
        [new_admin: Address]`"""
        return await self.invoke(
            "set_admin",
            [scval.to_address(new_admin)],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def admin(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[Address]:
        """Returns the admin of the contract.

        # Panics

        If the admin is not set."""
        return await self.invoke(
            "admin",
            [],
            parse_result_xdr_fn=lambda v: scval.from_address(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def set_authorized(
        self,
        id: Union[Address, str],
        authorize: bool,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[None]:
        """Sets whether the account is authorized to use its balance. If
        `authorized` is true, `id` should be able to use its balance.

        # Arguments

        * `id` - The address being (de-)authorized.
        * `authorize` - Whether or not `id` can use its balance.

        # Events

        Emits an event with topics `["set_authorized", id: Address], data =
        [authorize: bool]`"""
        return await self.invoke(
            "set_authorized",
            [scval.to_address(id), scval.to_bool(authorize)],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def symbol(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bytes]:
        """Returns the symbol for this token.

        # Panics

        If the contract has not yet been initialized."""
        return await self.invoke(
            "symbol",
            [],
            parse_result_xdr_fn=lambda v: scval.from_string(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def transfer(
        self,
        from_: Union[Address, str],
        to: Union[Address, str],
        amount: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[None]:
        """Transfer `amount` from `from` to `to`.

        # Arguments

        * `from` - The address holding the balance of tokens which will be
        withdrawn from.
        * `to` - The address which will receive the transferred tokens.
        * `amount` - The amount of tokens to be transferred.

        # Events

        Emits an event with topics `["transfer", from: Address, to: Address],
        data = amount: i128`"""
        return await self.invoke(
            "transfer",
            [scval.to_address(from_), scval.to_address(to), scval.to_int128(amount)],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def transfer_from(
        self,
        spender: Union[Address, str],
        from_: Union[Address, str],
        to: Union[Address, str],
        amount: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[None]:
        """Transfer `amount` from `from` to `to`, consuming the allowance that
        `spender` has on `from`'s balance. Authorized by spender
        (`spender.require_auth()`).

        The spender will be allowed to transfer the amount from from's balance
        if the amount is less than or equal to the allowance that the spender
        has on the from's balance. The spender's allowance on from's balance
        will be reduced by the amount.

        # Arguments

        * `spender` - The address authorizing the transfer, and having its
        allowance consumed during the transfer.
        * `from` - The address holding the balance of tokens which will be
        withdrawn from.
        * `to` - The address which will receive the transferred tokens.
        * `amount` - The amount of tokens to be transferred.

        # Events

        Emits an event with topics `["transfer", from: Address, to: Address],
        data = amount: i128`"""
        return await self.invoke(
            "transfer_from",
            [
                scval.to_address(spender),
                scval.to_address(from_),
                scval.to_address(to),
                scval.to_int128(amount),
            ],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )